rm(list = ls())
data=rbind(matrix(rep("nc",165),165,1,byrow=TRUE),matrix(rep("sc",70),70,1,byrow=TRUE))
View(data)
1000*runif(235))
rm(list = ls())
data=rbind(matrix(rep("nc",165),165,1,byrow=TRUE),matrix(rep("sc",70),70,1,byrow=TRUE))
data=cbind.data.frame(data,c(rep(1,100), rep(2,50), rep(3,15), rep(1,30),rep(2,40)),
1000*runif(235))
names(data)=c("state","region","income")
# computes the population stratum sizes
table(data$region,data$state)
View(data)
View(data)
table(data$region,data$state)
View(data)
s=strata(data,c("region","state"),size=c(10,5,10,4,6), method="srswor")
View(data)
difftime(strptime("Apr 17 2013 4:30:00:000PM", "%b %d %Y %H:%M:%S"),
strptime("Apr 17 2013 4:32:00:000PM", "%b %d %Y %H:%M:%S"))
as.difftime(strptime("Apr 17 2013 4:30:00:000PM", "%b %d %Y %H:%M:%S"),
strptime("Apr 17 2013 4:32:00:000PM", "%b %d %Y %H:%M:%S"))
a<-as.difftime(strptime("Apr 17 2013 4:30:00:000PM", "%b %d %Y %H:%M:%S"),
strptime("Apr 17 2013 4:32:00:000PM", "%b %d %Y %H:%M:%S"))
a<-difftime(strptime("Apr 17 2013 4:30:00:000PM", "%b %d %Y %H:%M:%S"),
strptime("Apr 17 2013 4:32:00:000PM", "%b %d %Y %H:%M:%S"))
a
as.numeric(difftime(strptime("Apr 17 2013 4:30:00:000PM", "%b %d %Y %H:%M:%S"),
strptime("Apr 17 2013 4:32:00:000PM", "%b %d %Y %H:%M:%S")))
as.numeric(difftime(strptime("Apr 17 2013 4:32:00:000PM", "%b %d %Y %H:%M:%S"),
strptime("Apr 17 2013 4:32:00:000PM", "%b %d %Y %H:%M:%S")))
vec5 <- 1:10
vec5
rm(l=ls())
rm(list=ls())
require("intervals")
install.packages("intervals", lib="C:/Program Files/R/R-3.2.0/library")
require("intervals")
A=rbind(A1=c(1,7), A2=c(2,5), A3=c(4, 16))
View(A)
B=rbind(B1=c(2,3), B2=c(2,20))
Aint<-Intervals(A)
Bint<-Intervals(B)
interval_overlap(Aint, Bint)
View(B)
View(A)
View(A)
View(B)
data <- c(a,b,c,d,e)
data <- c('a','b','c','d','e')
data <- as.data.frame(data)
data$start <- c(11,12,13,14,15)
data$end <- c(15,16,17,18,19)
View(data)
tapply(data,data$start <= 12 & data$end >= 12)
tapply(data,start <= 12 & end >= 12)
data_1 <- data[which(data$start <= 12 & data$end >= 12),]
View(data_1)
length(data[which(data$start <= 12 & data$end >= 12),])
length(which(data$start <= 12 & data$end >= 12))
for (i in 1:20)
{
length(which(data$start <= i & data$end >= i))
print(length)
}
for (i in 1:20)
{
x<-length(which(data$start <= i & data$end >= i))
print(x)
}
which((1:12)%%2 == 0)
type(which((1:12)%%2 == 0))
class(which((1:12)%%2 == 0))
mode(which((1:12)%%2 == 0))
c<-c(12,3,5,7,9)
b<-c(12,5,9)
c-b
match(c,b)
c(match(c,b))
match(b,c)
c(match(b,c))
b
c
b %in% c
c %in% b
c %w/o% c
c[c %in% b]
c[!c %in% b]
vec1 <- c(1, 10, 100, 1000, 10000)
vec2 <- c("New York", "Los Angeles", "Chicago", "Houston", "Philadelphia")
vec3 <- c(TRUE, FALSE, FALSE, TRUE)
vec4 <- c(2+5i, 3-2i)
vec5 <- 1:10
vec6 <- seq(from = 0, to = 10, by = 0.25)
vec7 <- rep(x = c('A', 'B'), times = 10)
which(vec2 %in% c('New York', 'Chicago'))
vec2 %in% c('New York', 'Chicago')
vec2[which(vec2 %in% c('New York', 'Chicago'))]
vec2 %in% c('New York', 'Chicago')
rm(list=ls())
library(TSA)
install.packages("TSA", lib="C:/Program Files/R/R-3.2.0/library")
install.packages("TTR", lib="C:/Program Files/R/R-3.2.0/library")
install.packages("fpp", lib="C:/Program Files/R/R-3.2.0/library")
library(fpp)
View(mfrow)
mfrow
par(mfrow=c(2,2))
plot(hsales)
plot(hsales,xlab="Year",ylab="Monthly housing sales (millions)")
plot(ustreas,xlab="Day",ylab="US treasury bill contracts")
plot(elec,xlab="Year",ylab="Australian monthly electricity production")
plot(diff(dj),xlab="Day",ylab="Daily change in Dow Jones index")
library(fpp)
install.packages("timeDate", lib="C:/Program Files/R/R-3.2.0/library")
library(fpp)
install.packages("fpp", lib="C:/Program Files/R/R-3.2.0/library")
library(fpp)
install.packages("forecast", lib="C:/Program Files/R/R-3.2.0/library")
library(dpp)
library(fpp)
library(forecast)
library(forecast)
library(forecast)
install.packages("forecast", lib="C:/Program Files/R/R-3.2.0/library")
library(forecast)
install.packages("quadprog", lib="C:/Program Files/R/R-3.2.0/library")
library(forecast)
library(fpp)
library(forecast)
View(myFunc)
View(myFunc)
View(myFunc)
View(myFunc)
View(myFunc)
version
library(tseries)
2^2
2**2
2**3
2^3
rm(list=ls())
xs <- seq(0,4,len=20) # create some values
# define the function we want to optimize
f <-  function(x) {
1.2 * (x-2)^2 + 3.2
}
plot(xs , f (xs), type="l",xlab="x",ylab=expression(1.2(x-2)^2 +3.2))
xs
set.seed(0)
xs <- seq(0,4,len=20) # create some values
# define the function we want to optimize
f <-  function(x) {
1.2 * (x-2)^2 + 3.2
}
# plot the function
plot(xs , f (xs), type="l",xlab="x",ylab=expression(1.2(x-2)^2 +3.2))
grad <- function(x){
1.2*2*(x-2)
}
lines (c (2,2), c (3,8), col="red",lty=2)
lines (c (2,2), c (3,8), col="red",lty=2)
lines (c (2,2), c (2,8), col="red",lty=2)
lines (c (2,2), c (3,8), col="red",lty=2)
lines (c (2,2), c (3,8), col="red",lty=2)
lines (c (2,2), c (2,8), col="red",lty=2)
plot(xs , f (xs), type="l",xlab="x",ylab=expression(1.2(x-2)^2 +3.2))
lines (c (2,2), c (2,8), col="red",lty=2)
plot(xs , f (xs), type="l",xlab="x",ylab=expression(1.2(x-2)^2 +3.2))
lines (c (2,2), c (3,8), col="red",lty=2)
text (2.1,7, "Closedform solution",col="red",pos=4)
text (2.1,7, "Closedform solution",col="red",pos=1)
text (2.1,7, "Closedform solution",col="red",pos=2)
text (2.1,7, "Closedform solution",col="red",pos=3)
text (2.1,7, "Closedform solution",col="red",pos=5)
text (2.1,7, "Closedform solution",col="red",pos=4)
set.seed(0)
xs <- seq(0,4,len=20) # create some values
# define the function we want to optimize
f <-  function(x) {
1.2 * (x-2)^2 + 3.2
}
# plot the function
plot(xs , f (xs), type="l",xlab="x",ylab=expression(1.2(x-2)^2 +3.2))
# calculate the gradeint df/dx
grad <- function(x){
1.2*2*(x-2)
}
# df/dx = 2.4(x-2), if x = 2 then 2.4(2-2) = 0
# The actual solution we will approximate with gradeint descent
# is  x = 2 as depicted in the plot below
lines (c (2,2), c (3,8), col="red",lty=2)
text (2.1,7, "Closedform solution",col="red",pos=4)
x <- 0.1 # initialize the first guess for x-value
xtrace <- x # store x -values for graphing purposes (initial)
ftrace <- f(x) # store y-values (function evaluated at x) for graphing purposes (initial)
stepFactor <- 0.6 # learning rate 'alpha'
for (step in 1:100) {
x <- x - stepFactor*grad(x) # gradient descent update
xtrace <- c(xtrace,x) # update for graph
ftrace <- c(ftrace,f(x)) # update for graph
}
lines ( xtrace , ftrace , type="b",col="blue")
text (0.5,6, "Gradient Descent",col="blue",pos= 4)
print(x) # x converges to 2.0
set.seed(0)
xs <- seq(0,4,len=20) # create some values
# define the function we want to optimize
f <-  function(x) {
1.2 * (x-2)^2 + 3.2
}
# plot the function
plot(xs , f (xs), type="l",xlab="x",ylab=expression(1.2(x-2)^2 +3.2))
# calculate the gradeint df/dx
grad <- function(x){
1.2*2*(x-2)
}
# df/dx = 2.4(x-2), if x = 2 then 2.4(2-2) = 0
# The actual solution we will approximate with gradeint descent
# is  x = 2 as depicted in the plot below
lines (c (2,2), c (3,8), col="red",lty=2)
text (2.1,7, "Closedform solution",col="red",pos=4)
# gradient descent implementation
x <- 0.1 # initialize the first guess for x-value
xtrace <- x # store x -values for graphing purposes (initial)
ftrace <- f(x) # store y-values (function evaluated at x) for graphing purposes (initial)
stepFactor <- 0.6 # learning rate 'alpha'
for (step in 1:100) {
x <- x - stepFactor*grad(x) # gradient descent update
xtrace <- c(xtrace,x) # update for graph
ftrace <- c(ftrace,f(x)) # update for graph
}
lines ( xtrace , ftrace , type="b",col="blue")
text (0.5,6, "Gradient Descent",col="blue",pos= 4)
# print final value of x
print(x) # x converges to 2.0
1:3
for i in 1:3
for i in [1:3]
setwd("C:/Users/rakesh.jasti/Desktop")
WHO = read.csv("WHO.csv")
str(WHO)
# Plot from Week 1
plot(WHO$GNI, WHO$FertilityRate)
library(ggplot2)
install.packages(c("ggplot2", "gtable", "htmltools", "munsell", "rmarkdown", "scales", "shiny"))
install.packages(c("BH", "boot", "cluster", "curl", "DataCombine", "DBI", "devtools", "digest", "evaluate", "fma", "forecast", "ggplot2", "git2r", "httr", "jsonlite", "knitr", "lubridate", "Matrix", "memoise", "mgcv", "nlme", "NLP", "nnet", "plotrix", "R6", "raster", "rattle", "Rcpp", "RcppArmadillo", "rmarkdown", "rstudioapi", "scales", "shiny", "slam", "sp", "stringi", "survival", "tseries", "xtable", "zoo"), lib="C:/Program Files/R/R-3.2.2/library")
ggplot(WHO, aes(x = FertilityRate, y = Under15)) + geom_point()
library("ggplot2", lib.loc="~/R/win-library/3.2")
ggplot(WHO, aes(x = FertilityRate, y = Under15)) + geom_point()
ggplot(WHO, aes(x = FertilityRate, y = Under15, color = Region)) + geom_point() + scale_color_brewer(palette="Dark2")
rm(list=ls())
mvt = read.csv("mvt.csv", stringsAsFactors=FALSE)
str(mvt)
mvt$Date = strptime(mvt$Date, format="%m/%d/%y %H:%M")
mvt$Weekday = weekdays(mvt$Date)
mvt$Hour = mvt$Date$hour
str(mvt)
table(mvt$Weekday)
WeekdayCounts = as.data.frame(table(mvt$Weekday))
View(WeekdayCounts)
str(WeekdayCounts)
library(ggplot2)
# Create our plot
ggplot(WeekdayCounts, aes(x=Var1, y=Freq)) + geom_line(aes(group=1))
WeekdayCounts$Var1 = factor(WeekdayCounts$Var1, ordered=TRUE, levels=c("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday","Saturday"))
# Try again:
ggplot(WeekdayCounts, aes(x=Var1, y=Freq)) + geom_line(aes(group=1))
ggplot(WeekdayCounts, aes(x=Var1, y=Freq)) + geom_line(aes(group=1)) + xlab("Day of the Week") + ylab("Total Motor Vehicle Thefts")
table(mvt$Weekday, mvt$Hour)
DayHourCounts = as.data.frame(table(mvt$Weekday, mvt$Hour))
str(DayHourCounts)
# Convert the second variable, Var2, to numbers and call it Hour:
typeof(DayHourCounts$Var2)
class(DayHourCounts$Var2)
ggplot(WeekdayCounts, aes(x=Var1, y=Freq)) + geom_line(aes(group=1), linetype=2) + xlab("Day of the Week") + ylab("Total Motor Vehicle Thefts")
ggplot(WeekdayCounts, aes(x=Var1, y=Freq)) + geom_line(aes(group=1), alpha=.3) + xlab("Day of the Week") + ylab("Total Motor Vehicle Thefts")
ggplot(WeekdayCounts, aes(x=Var1, y=Freq)) + geom_line(aes(group=1)) + xlab("Day of the Week") + ylab("Total Motor Vehicle Thefts")
ggplot(WeekdayCounts, aes(x=Var1, y=Freq)) + geom_line(aes(group=1), alpha=.3) + xlab("Day of the Week") + ylab("Total Motor Vehicle Thefts")
ggplot(DayHourCounts, aes(x=Hour, y=Freq)) + geom_line(aes(group=Var1))
DayHourCounts$Hour = as.numeric(as.character(DayHourCounts$Var2))
ggplot(DayHourCounts, aes(x=Hour, y=Freq)) + geom_line(aes(group=Var1))
str(DayHourCounts)
ggplot(DayHourCounts, aes(x=Hour, y=Freq)) + geom_line(aes(group=Var1, color=Var1), size=2)
DayHourCounts$Type = ifelse((DayHourCounts$Var1 == "Sunday") | (DayHourCounts$Var1 == "Saturday"), "Weekend", "Weekday")
# Redo our plot, this time coloring by Type:
ggplot(DayHourCounts, aes(x=Hour, y=Freq)) + geom_line(aes(group=Var1, color=Type), size=2)
ggplot(DayHourCounts, aes(x=Hour, y=Freq)) + geom_line(aes(group=Var1, color=Type), size=2, alpha=0.5)
DayHourCounts$Var1 = factor(DayHourCounts$Var1, ordered=TRUE, levels=c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"))
ggplot(DayHourCounts, aes(x = Hour, y = Var1)) + geom_tile(aes(fill = Freq))
ggplot(DayHourCounts, aes(x = Hour, y = Var1)) + geom_tile(aes(fill = Freq)) + scale_fill_gradient(name="Total MV Thefts") + theme(axis.title.y = element_blank())
ggplot(DayHourCounts, aes(x = Hour, y = Var1)) + geom_tile(aes(fill = Freq)) + scale_fill_gradient(name="Total MV Thefts", low="white", high="red") + theme(axis.title.y = element_blank())
library(maps)
library(ggmap)
install.packages("maps")
install.packages("ggmap")
library(maps)
library(ggmap)
library(maps)
install.packages("ggmap")
library(ggmap)
install.packages("ggmap", lib="C:/Program Files/R/R-3.2.2/library")
library(ggmap)
library(ggmap)
library(ggmap)
library(ggmap)
library(ggmap)
library(ggmap)
chicago = get_map(location = "chicago", zoom = 11)
# Look at the map
ggmap(chicago)
ggmap(chicago) + geom_point(data = mvt[1:100,], aes(x = Longitude, y = Latitude))
LatLonCounts = as.data.frame(table(round(mvt$Longitude,2), round(mvt$Latitude,2)))
str(LatLonCounts)
View(LatLonCounts)
table(round(mvt$Longitude,2), round(mvt$Latitude,2))
str(LatLonCounts)
# Convert our Longitude and Latitude variable to numbers:
LatLonCounts$Long = as.numeric(as.character(LatLonCounts$Var1))
LatLonCounts$Lat = as.numeric(as.character(LatLonCounts$Var2))
# Plot these points on our map:
ggmap(chicago) + geom_point(data = LatLonCounts, aes(x = Long, y = Lat, color = Freq, size=Freq))
ggmap(chicago) + geom_point(data = LatLonCounts, aes(x = Long, y = Lat, color = Freq, size=Freq)) + scale_colour_gradient(low="yellow", high="red")
ggmap(chicago) + geom_tile(data = LatLonCounts, aes(x = Long, y = Lat, alpha = Freq), fill="red")
LatLonCounts2 = subset(LatLonCounts, Freq>0)
nrow(LatLonCounts2)
1638-686
murders = read.csv("murders.csv")
str(murders)
# Load the map of the US
statesMap = map_data("state")
str(statesMap)
rm(list = ls())
murders = read.csv("murders.csv")
str(murders)
# Load the map of the US
statesMap = map_data("state")
str(statesMap)
ggplot(statesMap, aes(x = long, y = lat, group = group)) + geom_polygon(fill = "white", color = "black")
murders$region = tolower(murders$State)
murderMap = merge(statesMap, murders, by="region")
str(murderMap)
# Plot the number of murder on our map of the United States:
ggplot(murderMap, aes(x = long, y = lat, group = group, fill = Murders)) + geom_polygon(color = "black") + scale_fill_gradient(low = "black", high = "red", guide = "legend")
ggplot(murderMap, aes(x = long, y = lat, group = group, fill = Population)) + geom_polygon(color = "black") + scale_fill_gradient(low = "black", high = "red", guide = "legend")
ggplot(murderMap, aes(x = long, y = lat, group = group, fill = MurderRate)) + geom_polygon(color = "black") + scale_fill_gradient(low = "black", high = "red", guide = "legend")
# Redo the plot, removing any states with murder rates above 10:
murderMap$MurderRate = murderMap$Murders / murderMap$Population * 100000
# Redo our plot with murder rate:
ggplot(murderMap, aes(x = long, y = lat, group = group, fill = MurderRate)) + geom_polygon(color = "black") + scale_fill_gradient(low = "black", high = "red", guide = "legend")
# Redo the plot, removing any states with murder rates above 10:
ggplot(murderMap, aes(x = long, y = lat, group = group, fill = MurderRate)) + geom_polygon(color = "black") + scale_fill_gradient(low = "black", high = "red", guide = "legend", limits = c(0,10))
library("ggplot2")
library("maps")
library("ggmap")
statesMap = map_data("state")
rm(list=ls())
statesMap = map_data("state")
str(statesMap)
length(statesMap$group)
length(unique(statesMap$group))
ggplot(statesMap, aes=(x=long, y=lat, group=group)) + geom_polygon(fill = 'white', color='black')
ggplot(statesMap, aes(x=long, y=lat, group=group)) + geom_polygon(fill = 'white', color='black')
setwd("C:/Users/rakesh.jasti/Desktop/electionForecasting")
polling = read.csv("PollingImputed.csv")
str(polling)
Train = subset(polling, Year==2004 || Year==2008)
View(Train)
Train = subset(polling, Year!=2012)
View(Train)
Test = subset(polling, Year==2012)
mod2 = glm(Republican~SurveyUSA+DiffCount, data=Train, family="binomial")
estPrediction = predict(mod2, newdata=Test, type="response")
TestPrediction = predict(mod2, newdata=Test, type="response")
TestPredictionBinary = as.numeric(TestPrediction > 0.5)
predictionDataFrame = data.frame(TestPrediction, TestPredictionBinary, Test$State)
table(TestPredictionBinary)
View(predictionDataFrame)
mean(ppredictionDataFrame$TestPrediction)
predictionDataFrame = data.frame(TestPrediction, TestPredictionBinary, Test$State)
mean(predictionDataFrame$TestPrediction)
predictionDataFrame$region = tolower(predictionDataFrame$Test.State)
predictionMap = merge(statesMap, predictionDataFrame, by = "region")
View(predictionMap)
predictionMap = predictionMap[order(predictionMap$order),]
?merge
View(statesMap)
ggplot(predictionMap, aes(x = long, y = lat, group = group, fill = TestPredictionBinary)) + geom_polygon(color = "black")
ggplot(predictionMap, aes(x = long, y = lat, group = group, fill = TestPredictionBinary))+ geom_polygon(color = "black") + scale_fill_gradient(low = "blue", high = "red", guide = "legend", breaks= c(0,1), labels = c("Democrat", "Republican"), name = "Prediction 2012")
c(1,10)
ggplot(predictionMap, aes(x = long, y = lat, group = group, fill = TestPrediction))+ geom_polygon(color = "black") + scale_fill_gradient(low = "blue", high = "red", guide = "legend", breaks= c(0,1), labels = c("Democrat", "Republican"), name = "Prediction 2012")
ggplot(predictionMap, aes(x = long, y = lat, group = group, fill = TestPrediction))+ geom_polygon(color = "black") + scale_fill_gradient(low = "blue", high = "red", guide = "legend", labels = c("Democrat", "Republican"), name = "Prediction 2012")
ggplot(predictionMap, aes(x = long, y = lat, group = group, fill = TestPrediction))+ geom_polygon(color = "black") + scale_fill_gradient(low = "blue", high = "red", guide = "legend", name = "Prediction 2012")
ggplot(predictionMap, aes(x = long, y = lat, group = group, fill = TestPredictionBinary))+ geom_polygon(color = "black") + scale_fill_gradient(low = "blue", high = "red", guide = "legend", breaks= c(0,1), labels = c("Democrat", "Republican"), name = "Prediction 2012")
ggplot(predictionMap, aes(x = long, y = lat, group = group, fill = TestPredictionBinary)) + geom_polygon(color = "black")
ggplot(predictionMap, aes(x = long, y = lat, group = group, fill = TestPredictionBinary))+ geom_polygon(color = "black") + scale_fill_gradient(low = "blue", high = "red", guide = "legend", breaks= c(0,1), labels = c("Democrat", "Republican"), name = "Prediction 2012")
ggplot(predictionMap, aes(x = long, y = lat, group = group, fill = TestPrediction))+ geom_polygon(color = "black") + scale_fill_gradient(low = "blue", high = "red", guide = "legend", name = "Prediction 2012")
ggplot(predictionMap, aes(x = long, y = lat, group = group, fill = TestPredictionBinary))+ geom_polygon(color = "black") + scale_fill_gradient(low = "blue", high = "red", guide = "legend", breaks= c(0,1), labels = c("Democrat", "Republican"), name = "Prediction 2012")
ggplot(predictionMap, aes(x = long, y = lat, group = group, fill = TestPrediction))+ geom_polygon(color = "black") + scale_fill_gradient(low = "blue", high = "red", guide = "legend", name = "Prediction 2012")
ggplot(predictionMap, aes(x = long, y = lat, group = group, fill = TestPrediction))+ geom_polygon(color = "black") + scale_fill_gradient(low = "blue", high = "red", guide = "legend", name = "Prediction 2012")
ggplot(predictionMap, aes(x = long, y = lat, group = group, fill = TestPredictionBinary))+ geom_polygon(color = "black") + scale_fill_gradient(low = "blue", high = "red", guide = "legend", breaks= c(0,1), labels = c("Democrat", "Republican"), name = "Prediction 2012")
View(predictionMap)
subset(predictionMap, region=='florida')[1]
subset(predictionMap, region=='florida')[1,]
ggplot(predictionMap, aes(x = long, y = lat, group = group, fill = TestPrediction))+ geom_polygon(color = "black") + scale_fill_gradient(low = "blue", high = "red", guide = "legend", name = "Prediction 2012")
ggplot(predictionMap, aes(x = long, y = lat, group = group, fill = TestPredictionBinary))+ geom_polygon(color = "black", alpha = .3) + scale_fill_gradient(low = "blue", high = "red", guide = "legend", breaks= c(0,1), labels = c("Democrat", "Republican"), name = "Prediction 2012")
ggplot(predictionMap, aes(x = long, y = lat, group = group, fill = TestPredictionBinary))+ geom_polygon(color = "black", line = .3) + scale_fill_gradient(low = "blue", high = "red", guide = "legend", breaks= c(0,1), labels = c("Democrat", "Republican"), name = "Prediction 2012")
?geom_polygon
ggplot(predictionMap, aes(x = long, y = lat, group = group, fill = TestPredictionBinary))+ geom_polygon(color = "black", linetype = .3) + scale_fill_gradient(low = "blue", high = "red", guide = "legend", breaks= c(0,1), labels = c("Democrat", "Republican"), name = "Prediction 2012")
ggplot(predictionMap, aes(x = long, y = lat, group = group, fill = TestPredictionBinary))+ geom_polygon(color = "black", size = .3) + scale_fill_gradient(low = "blue", high = "red", guide = "legend", breaks= c(0,1), labels = c("Democrat", "Republican"), name = "Prediction 2012")
ggplot(predictionMap, aes(x = long, y = lat, group = group, fill = TestPredictionBinary))+ geom_polygon(color = "black", linetype = 3) + scale_fill_gradient(low = "blue", high = "red", guide = "legend", breaks= c(0,1), labels = c("Democrat", "Republican"), name = "Prediction 2012")
ggplot(predictionMap, aes(x = long, y = lat, group = group, fill = TestPredictionBinary))+ geom_polygon(color = "black", size = 3) + scale_fill_gradient(low = "blue", high = "red", guide = "legend", breaks= c(0,1), labels = c("Democrat", "Republican"), name = "Prediction 2012")
rm(list=ls())
setwd("C:/Users/rakesh.jasti/Desktop/socialNetwork")
edges = read.csv("edges.csv")
users = read.csv("users.csv")
146/59
View(edges)
table(edges$V1)
146*2/59
View(users)
!T
table(subset(users, !is.na(school))$locale)
table(users$school, users$gender)
install.packages("igraph", lib="C:/Program Files/R/R-3.2.2/library")
?graph.data.frame()
library(igraph)
?graph.data.frame()
g = graph.data.frame(edges, FALSE, users)
plot(g, vertex.size=5, vertex.label=NA)
plot(g)
plot(g, vertex.size=5)
plot(g, vertex.size=5, vertex.label=NA)
degree(g)
?degree
table(degree(g)
table(degree(g))
table(degree(g))
V(g)$size = degree(g)/2+2
?V
V(g)
plot(g, vertex.label=NA)
V(g)$color = "black"
V(g)$color[V(g)$gender == "A"] = "red"
V(g)$color[V(g)$gender == "B"] = "gray"
plot(g, vertex.label = NA)
V(g)$color = "black"
V(g)$color[V(g)$school == "A"] = "red"
V(g)$color[V(g)$school == "AB"] = "gray"
plot(g, vertex.label = NA)
V(g)$color = "black"
V(g)$color[V(g)$locale == "A"] = "red"
V(g)$color[V(g)$locale == "B"] = "gray"
plot(g, vertex.label = NA)
?igraph.plotting
setwd("C:/Users/rakesh.jasti/Desktop/textData")
rm(list=ls())
tweets = read.csv('tweets.csv', stringsAsFactors = F)
library(tm)
library(SnowballC)
corpus = Corpus(VectorSource(tweets$Tweet))
corpus = Corpus(VectorSource(tweets$Tweet))
corpus = tm_map(corpus, tolower)      # All chars to lowercase
corpus = tm_map(corpus, PlainTextDocument)
corpus = tm_map(corpus, removePunctuation)      # remove punctuation
stopwords("english")[1:10]      # first 10 stopwords
corpus = tm_map(corpus, removeWords, c(stopwords("english")))
frequencies <- DocumentTermMatrix(corpus)
allTweets = as.data.frame(as.matrix(frequencies))
View(allTweets)
install.packages("wordcloud", lib="C:/Program Files/R/R-3.2.2/library")
library(wordcloud)
?wordcloud
wordcloud(colnames(allTweets), colSums(allTweets))
?wordcloud
wordcloud(colnames(allTweets), colSums(allTweets), scale = (2, .1))
wordcloud(colnames(allTweets), colSums(allTweets), scale = c(2, .1))
corpus = Corpus(VectorSource(tweets$Tweet))
corpus = tm_map(corpus, tolower)      # All chars to lowercase
corpus = tm_map(corpus, PlainTextDocument)
corpus = tm_map(corpus, removePunctuation)      # remove punctuation
# Removing all stopwords & the word "apple" since all tweets have the word apple
corpus = tm_map(corpus, removeWords, c('apple', stopwords("english")))
# document term matrix where each row is a tweet and each column is frequency of the word
frequencies <- DocumentTermMatrix(corpus)
allTweets = as.data.frame(as.matrix(frequencies))
wordcloud(colnames(allTweets), colSums(allTweets), scale = c(2, .1))
?wordcloud
wordcloud(colnames(allTweets), colSums(allTweets), scale = c(2, .1), random.order = TRUE)
wordcloud(colnames(allTweets), colSums(allTweets), scale = c(2, .1), random.order = FALSE)
?wordcloud
wordcloud(colnames(allTweets), colSums(allTweets), scale = c(2, .1), rot.per = .1)
wordcloud(colnames(allTweets), colSums(allTweets), scale = c(2, .1), rot.per = 1)
wordcloud(colnames(allTweets), colSums(allTweets), scale = c(2, .1), rot.per = 10)
wordcloud(colnames(allTweets), colSums(allTweets), scale = c(2, .1), rot.per = -1)
wordcloud(colnames(allTweets), colSums(allTweets), scale = c(2, .1), rot.per = -2)
wordcloud(colnames(allTweets), colSums(allTweets), scale = c(2, .1), rot.per = -5)
wordcloud(colnames(allTweets), colSums(allTweets), scale = c(2, .1), rot.per = -10)
wordcloud(colnames(allTweets), colSums(allTweets), scale = c(2, .1))
install.packages("RColorBrewer", lib="C:/Program Files/R/R-3.2.2/library")
library('RColorBrewer')
library(tm)
library(SnowballC)
library(wordcloud)
brewer.pal()
library('RColorBrewer')
brewer.pal()
display.brewer.all()
wordcloud(colnames(allTweets), colSums(allTweets), scale = c(2, .1), colors=brewer.pal(9, "Blues"))
