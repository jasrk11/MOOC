rm(list = ls())
data=rbind(matrix(rep("nc",165),165,1,byrow=TRUE),matrix(rep("sc",70),70,1,byrow=TRUE))
View(data)
1000*runif(235))
rm(list = ls())
data=rbind(matrix(rep("nc",165),165,1,byrow=TRUE),matrix(rep("sc",70),70,1,byrow=TRUE))
data=cbind.data.frame(data,c(rep(1,100), rep(2,50), rep(3,15), rep(1,30),rep(2,40)),
1000*runif(235))
names(data)=c("state","region","income")
# computes the population stratum sizes
table(data$region,data$state)
View(data)
View(data)
table(data$region,data$state)
View(data)
s=strata(data,c("region","state"),size=c(10,5,10,4,6), method="srswor")
View(data)
difftime(strptime("Apr 17 2013 4:30:00:000PM", "%b %d %Y %H:%M:%S"),
strptime("Apr 17 2013 4:32:00:000PM", "%b %d %Y %H:%M:%S"))
as.difftime(strptime("Apr 17 2013 4:30:00:000PM", "%b %d %Y %H:%M:%S"),
strptime("Apr 17 2013 4:32:00:000PM", "%b %d %Y %H:%M:%S"))
a<-as.difftime(strptime("Apr 17 2013 4:30:00:000PM", "%b %d %Y %H:%M:%S"),
strptime("Apr 17 2013 4:32:00:000PM", "%b %d %Y %H:%M:%S"))
a<-difftime(strptime("Apr 17 2013 4:30:00:000PM", "%b %d %Y %H:%M:%S"),
strptime("Apr 17 2013 4:32:00:000PM", "%b %d %Y %H:%M:%S"))
a
as.numeric(difftime(strptime("Apr 17 2013 4:30:00:000PM", "%b %d %Y %H:%M:%S"),
strptime("Apr 17 2013 4:32:00:000PM", "%b %d %Y %H:%M:%S")))
as.numeric(difftime(strptime("Apr 17 2013 4:32:00:000PM", "%b %d %Y %H:%M:%S"),
strptime("Apr 17 2013 4:32:00:000PM", "%b %d %Y %H:%M:%S")))
vec5 <- 1:10
vec5
rm(l=ls())
rm(list=ls())
require("intervals")
install.packages("intervals", lib="C:/Program Files/R/R-3.2.0/library")
require("intervals")
A=rbind(A1=c(1,7), A2=c(2,5), A3=c(4, 16))
View(A)
B=rbind(B1=c(2,3), B2=c(2,20))
Aint<-Intervals(A)
Bint<-Intervals(B)
interval_overlap(Aint, Bint)
View(B)
View(A)
View(A)
View(B)
data <- c(a,b,c,d,e)
data <- c('a','b','c','d','e')
data <- as.data.frame(data)
data$start <- c(11,12,13,14,15)
data$end <- c(15,16,17,18,19)
View(data)
tapply(data,data$start <= 12 & data$end >= 12)
tapply(data,start <= 12 & end >= 12)
data_1 <- data[which(data$start <= 12 & data$end >= 12),]
View(data_1)
length(data[which(data$start <= 12 & data$end >= 12),])
length(which(data$start <= 12 & data$end >= 12))
for (i in 1:20)
{
length(which(data$start <= i & data$end >= i))
print(length)
}
for (i in 1:20)
{
x<-length(which(data$start <= i & data$end >= i))
print(x)
}
which((1:12)%%2 == 0)
type(which((1:12)%%2 == 0))
class(which((1:12)%%2 == 0))
mode(which((1:12)%%2 == 0))
c<-c(12,3,5,7,9)
b<-c(12,5,9)
c-b
match(c,b)
c(match(c,b))
match(b,c)
c(match(b,c))
b
c
b %in% c
c %in% b
c %w/o% c
c[c %in% b]
c[!c %in% b]
vec1 <- c(1, 10, 100, 1000, 10000)
vec2 <- c("New York", "Los Angeles", "Chicago", "Houston", "Philadelphia")
vec3 <- c(TRUE, FALSE, FALSE, TRUE)
vec4 <- c(2+5i, 3-2i)
vec5 <- 1:10
vec6 <- seq(from = 0, to = 10, by = 0.25)
vec7 <- rep(x = c('A', 'B'), times = 10)
which(vec2 %in% c('New York', 'Chicago'))
vec2 %in% c('New York', 'Chicago')
vec2[which(vec2 %in% c('New York', 'Chicago'))]
vec2 %in% c('New York', 'Chicago')
rm(list=ls())
library(TSA)
install.packages("TSA", lib="C:/Program Files/R/R-3.2.0/library")
install.packages("TTR", lib="C:/Program Files/R/R-3.2.0/library")
install.packages("fpp", lib="C:/Program Files/R/R-3.2.0/library")
library(fpp)
View(mfrow)
mfrow
par(mfrow=c(2,2))
plot(hsales)
plot(hsales,xlab="Year",ylab="Monthly housing sales (millions)")
plot(ustreas,xlab="Day",ylab="US treasury bill contracts")
plot(elec,xlab="Year",ylab="Australian monthly electricity production")
plot(diff(dj),xlab="Day",ylab="Daily change in Dow Jones index")
library(fpp)
install.packages("timeDate", lib="C:/Program Files/R/R-3.2.0/library")
library(fpp)
install.packages("fpp", lib="C:/Program Files/R/R-3.2.0/library")
library(fpp)
install.packages("forecast", lib="C:/Program Files/R/R-3.2.0/library")
library(dpp)
library(fpp)
library(forecast)
library(forecast)
library(forecast)
install.packages("forecast", lib="C:/Program Files/R/R-3.2.0/library")
library(forecast)
install.packages("quadprog", lib="C:/Program Files/R/R-3.2.0/library")
library(forecast)
library(fpp)
library(forecast)
View(myFunc)
View(myFunc)
View(myFunc)
View(myFunc)
View(myFunc)
version
library(tseries)
2^2
2**2
2**3
2^3
rm(list=ls())
xs <- seq(0,4,len=20) # create some values
# define the function we want to optimize
f <-  function(x) {
1.2 * (x-2)^2 + 3.2
}
plot(xs , f (xs), type="l",xlab="x",ylab=expression(1.2(x-2)^2 +3.2))
xs
set.seed(0)
xs <- seq(0,4,len=20) # create some values
# define the function we want to optimize
f <-  function(x) {
1.2 * (x-2)^2 + 3.2
}
# plot the function
plot(xs , f (xs), type="l",xlab="x",ylab=expression(1.2(x-2)^2 +3.2))
grad <- function(x){
1.2*2*(x-2)
}
lines (c (2,2), c (3,8), col="red",lty=2)
lines (c (2,2), c (3,8), col="red",lty=2)
lines (c (2,2), c (2,8), col="red",lty=2)
lines (c (2,2), c (3,8), col="red",lty=2)
lines (c (2,2), c (3,8), col="red",lty=2)
lines (c (2,2), c (2,8), col="red",lty=2)
plot(xs , f (xs), type="l",xlab="x",ylab=expression(1.2(x-2)^2 +3.2))
lines (c (2,2), c (2,8), col="red",lty=2)
plot(xs , f (xs), type="l",xlab="x",ylab=expression(1.2(x-2)^2 +3.2))
lines (c (2,2), c (3,8), col="red",lty=2)
text (2.1,7, "Closedform solution",col="red",pos=4)
text (2.1,7, "Closedform solution",col="red",pos=1)
text (2.1,7, "Closedform solution",col="red",pos=2)
text (2.1,7, "Closedform solution",col="red",pos=3)
text (2.1,7, "Closedform solution",col="red",pos=5)
text (2.1,7, "Closedform solution",col="red",pos=4)
set.seed(0)
xs <- seq(0,4,len=20) # create some values
# define the function we want to optimize
f <-  function(x) {
1.2 * (x-2)^2 + 3.2
}
# plot the function
plot(xs , f (xs), type="l",xlab="x",ylab=expression(1.2(x-2)^2 +3.2))
# calculate the gradeint df/dx
grad <- function(x){
1.2*2*(x-2)
}
# df/dx = 2.4(x-2), if x = 2 then 2.4(2-2) = 0
# The actual solution we will approximate with gradeint descent
# is  x = 2 as depicted in the plot below
lines (c (2,2), c (3,8), col="red",lty=2)
text (2.1,7, "Closedform solution",col="red",pos=4)
x <- 0.1 # initialize the first guess for x-value
xtrace <- x # store x -values for graphing purposes (initial)
ftrace <- f(x) # store y-values (function evaluated at x) for graphing purposes (initial)
stepFactor <- 0.6 # learning rate 'alpha'
for (step in 1:100) {
x <- x - stepFactor*grad(x) # gradient descent update
xtrace <- c(xtrace,x) # update for graph
ftrace <- c(ftrace,f(x)) # update for graph
}
lines ( xtrace , ftrace , type="b",col="blue")
text (0.5,6, "Gradient Descent",col="blue",pos= 4)
print(x) # x converges to 2.0
set.seed(0)
xs <- seq(0,4,len=20) # create some values
# define the function we want to optimize
f <-  function(x) {
1.2 * (x-2)^2 + 3.2
}
# plot the function
plot(xs , f (xs), type="l",xlab="x",ylab=expression(1.2(x-2)^2 +3.2))
# calculate the gradeint df/dx
grad <- function(x){
1.2*2*(x-2)
}
# df/dx = 2.4(x-2), if x = 2 then 2.4(2-2) = 0
# The actual solution we will approximate with gradeint descent
# is  x = 2 as depicted in the plot below
lines (c (2,2), c (3,8), col="red",lty=2)
text (2.1,7, "Closedform solution",col="red",pos=4)
# gradient descent implementation
x <- 0.1 # initialize the first guess for x-value
xtrace <- x # store x -values for graphing purposes (initial)
ftrace <- f(x) # store y-values (function evaluated at x) for graphing purposes (initial)
stepFactor <- 0.6 # learning rate 'alpha'
for (step in 1:100) {
x <- x - stepFactor*grad(x) # gradient descent update
xtrace <- c(xtrace,x) # update for graph
ftrace <- c(ftrace,f(x)) # update for graph
}
lines ( xtrace , ftrace , type="b",col="blue")
text (0.5,6, "Gradient Descent",col="blue",pos= 4)
# print final value of x
print(x) # x converges to 2.0
1:3
for i in 1:3
for i in [1:3]
library("ggplot2")
library("maps")
library("ggmap")
setwd("C:/Users/rakesh.jasti/Desktop/electionForecasting")
rm(list = ls())
statesMap = map_data("state")
str(statesMap)
length(unique(statesMap$group))
rm(list = ls())
